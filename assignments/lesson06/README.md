# Урок 6: Обобщённое программирование и шаблоны

#### Введение

Обобщённое программирование — это стиль программирования, в котором разрабатываются алгоритмы и структуры данных, применимые к широкому спектру типов данных. Одним из основных инструментов обобщённого программирования в C++ являются **шаблоны**. Они позволяют писать универсальный код, который можно адаптировать к различным типам данных, что повышает гибкость, переиспользуемость и эффективность программ.

Этот урок познакомит вас с основами шаблонов в C++: как их использовать для создания шаблонных функций и классов, как специализировать шаблоны и как применять метапрограммирование для создания сложных решений на основе шаблонов.

Также мы начнем изучать thread и рассмотрим основные проблемы при создании мультипоточных приложений.

---

### 1. Основы шаблонов: функции и классы

Шаблоны в C++ делятся на два основных типа: **шаблоны функций** и **шаблоны классов**.

#### 1.1. Шаблоны функций

Шаблон функции позволяет определять функцию, которая может работать с различными типами данных без дублирования кода. Вместо того, чтобы писать несколько версий функции для каждого типа, мы определяем одну функцию, которая работает с параметризованным типом.

Пример шаблона функции:

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

Здесь `template <typename T>` сообщает компилятору, что `T` — это тип, который будет определён при вызове функции. В этом примере функция `max` может принимать параметры любого типа, например, `int`, `double`, `char` и т.д.

Использование шаблонной функции:

```cpp
int main() {
    int a = 5, b = 10;
    double x = 5.5, y = 3.3;

    std::cout << max(a, b) << std::endl;  // выводит 10
    std::cout << max(x, y) << std::endl;  // выводит 5.5
    return 0;
}
```

#### 1.2. Шаблоны классов

Шаблон класса работает аналогично шаблону функции, но применяется для создания универсальных классов. Шаблоны классов полезны, когда нужно создать классы, способные работать с различными типами данных.

Пример шаблона класса:

```cpp
template <typename T>
class Box {
private:
    T value;
public:
    Box(T v) : value(v) {}
    T getValue() {
        return value;
    }
};
```

Этот шаблон класса `Box` может хранить значение любого типа и предоставляет метод `getValue()` для доступа к этому значению.

Использование шаблона класса:

```cpp
int main() {
    Box<int> intBox(123);
    Box<double> doubleBox(45.67);

    std::cout << intBox.getValue() << std::endl;  // выводит 123
    std::cout << doubleBox.getValue() << std::endl;  // выводит 45.67
    return 0;
}
```

---

### 2. Специализация шаблонов и её использование

Иногда необходимо создать специальную версию шаблона для работы с определённым типом данных. Для этого используется **специализация шаблонов**. В C++ есть два вида специализаций: **полная** и **частичная**.

#### 2.1. Полная специализация

Полная специализация позволяет создать специализированную реализацию шаблона для конкретного типа. Например, можно создать шаблон функции, которая будет работать по-особому с типом `char`.

Пример полной специализации шаблона функции:

```cpp
template <>
char max<char>(char a, char b) {
    std::cout << "Специальная версия для char" << std::endl;
    return (a > b) ? a : b;
}
```

Здесь мы указали, что для типа `char` будет использоваться своя версия функции `max`.

#### 2.2. Частичная специализация

Частичная специализация применяется только к шаблонам классов. Она позволяет специализировать класс только для части типов, сохраняя общую реализацию для остальных.

Пример частичной специализации:

```cpp
template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;
    Pair(T1 f, T2 s) : first(f), second(s) {}
};

// Частичная специализация для случая, когда оба типа одинаковы
template <typename T>
class Pair<T, T> {
public:
    T first;
    T second;
    Pair(T f, T s) : first(f), second(s) {}
    void print() {
        std::cout << "Оба элемента одинаковы: " << first << ", " << second << std::endl;
    }
};
```

Здесь шаблон класса `Pair` в частично специализированной версии применим, если оба параметра типа одинаковы. 

---

### 3. Метапрограммирование с шаблонами

**Метапрограммирование** — это стиль программирования, в котором программы создают другие программы на этапе компиляции. Шаблоны C++ поддерживают метапрограммирование, позволяя производить вычисления на этапе компиляции, тем самым уменьшая накладные расходы времени выполнения.

Одним из популярных примеров метапрограммирования в C++ является вычисление факториала на этапе компиляции с помощью шаблонов.

Пример:

```cpp
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

// Специализация для случая N = 0
template <>
struct Factorial<0> {
    static const int value = 1;
};

int main() {
    std::cout << "Факториал 5: " << Factorial<5>::value << std::endl;  // выводит 120
    return 0;
}
```

Здесь мы используем рекурсивные шаблоны для вычисления факториала на этапе компиляции. Шаблон `Factorial<N>` рекурсивно умножает `N` на значение факториала `N - 1`, пока не достигнет базового случая `N = 0`.

#### Преимущества метапрограммирования:

1. **Вычисления на этапе компиляции**: Оптимизация времени выполнения за счёт предварительных вычислений.
2. **Сокращение дублирования кода**: Возможность автоматизировать создание кода.
3. **Безопасность типов**: Метапрограммирование позволяет создавать обобщённые алгоритмы, которые проверяются на этапе компиляции, уменьшая вероятность ошибок во время выполнения.

---

### Заключение

Шаблоны в C++ являются мощным инструментом, позволяющим реализовывать обобщённое программирование. Вы научились создавать шаблонные функции и классы, узнали о специализации шаблонов и познакомились с метапрограммированием с использованием шаблонов. Эти концепции позволяют писать более гибкий и эффективный код, который можно адаптировать к различным задачам и типам данных.

-----

# 4. Потоки (threads) в C++

#### Цели урока:
1. Понять, что такое потоки (threads) в C++.
2. Изучить, как создавать и управлять потоками.
3. Рассмотреть основные проблемы многопоточности и способы их решения.

### 4.1 Что такое поток - thread?

**Поток** (или **thread**) — это последовательность выполнения инструкций, которая может работать параллельно с другими потоками. Потоки позволяют программе выполнять несколько операций одновременно, что может значительно повысить производительность и отзывчивость.

#### Примеры использования потоков:

- **Параллельные вычисления**: В научных расчетах, где одни операции могут выполняться независимо от других.
- **Интерфейсы пользователя**: В графических приложениях, чтобы интерфейс оставался отзывчивым во время выполнения длительных операций.
- **Сетевые приложения**: Для обработки нескольких подключений одновременно.

---

### 4.2 Основы работы с потоками в C++

C++ предоставляет библиотеку `thread`, которая упрощает создание и управление потоками.

#### Подключение библиотеки:

Чтобы работать с потоками в C++, необходимо подключить библиотеку:

```cpp
#include <thread>
```

#### Создание потока:

Для создания потока используйте следующий синтаксис:

```cpp
std::thread имя_потока(функция_или_лямбда_выражение, аргументы);
```

#### Пример:

```cpp
#include <iostream>
#include <thread>

// Функция, которая будет выполняться в потоке
void threadFunction() {
    std::cout << "Hello from the thread!" << std::endl;
}

int main() {
    // Создаем поток
    std::thread thread(threadFunction);

    // Ожидаем завершения потока
    thread.join();  

    return 0;
}
```

### 4.3 Основные функции для работы с потоками

- **`join()`**: Ожидает завершения потока.
- **`detach()`**: Отделяет поток от родительского потока, позволяя ему работать независимо.

#### Пример с `detach()`:

```cpp
#include <iostream>
#include <thread>
#include <chrono>

void someFunction() {
    std::cout << "Поток работает!" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "Поток завершен!" << std::endl;
}

int main() {
    std::thread thread(someFunction);
    thread.detach(); // Отделяем поток, чтобы он работал независимо

    std::cout << "Основной поток продолжает работу..." << std::endl;

    // Даем время для завершения потока
    std::this_thread::sleep_for(std::chrono::seconds(3));
    
    return 0;
}
```

#### **Понимание `detach` и `join`**

- **`detach()`**:
  - Когда вы вызываете `detach()` на потоке, вы делаете его независимым от основного потока. Это значит, что поток будет работать в фоновом режиме, и вы не сможете дождаться его завершения с помощью `join()`.
  - После `detach()` вы не можете больше взаимодействовать с потоком, и любые попытки вызвать `join()` на этом потоке приведут к ошибке. Поток будет продолжать выполняться до своего завершения, и его ресурсы будут освобождены автоматически, когда он завершит выполнение.

- **`join()`**:
  - Когда вы вызываете `join()` на потоке, вы блокируете основной поток до тех пор, пока указанный поток не завершится.
  - Это означает, что если бы вы вызвали `join()` вместо `detach()`, основной поток ожидал бы завершения потока `t`, прежде чем продолжить выполнение. Это создает зависимость между основным потоком и потоком сыном.

#### **Лучшие практики**

Если вам нужно, чтобы основной поток ожидал завершения потока, лучше использовать `join()`:

- Если вы хотите дождаться завершения потока, не используйте `detach()`.
- Если вам действительно нужно отделить поток, и вы хотите, чтобы основной поток продолжал работать, но всё же обеспечить правильное завершение, можно использовать дополнительные механизмы синхронизации, такие как `std::future` и `std::promise` или другие условия.

### 4.4 Проблемы многопоточности

При работе с потоками важно учитывать некоторые проблемы:

- **Состояние гонки (Race Condition)**: Это происходит, когда два или более потока одновременно изменяют одно и то же значение. Это может привести к непредсказуемым результатам.

- **Блокировка (Deadlock)**: Это ситуация, когда два или более потока блокируют друг друга, ожидая освобождения ресурсов.

# 5. Защита данных с помощью мьютексов

Для защиты данных от состояния гонки используются **мьютексы** (mutexes). Мьютекс — это механизм синхронизации, который позволяет только одному потоку в данный момент времени получить доступ к ресурсу.

#### Пример использования мьютексов:

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex; // Мьютекс для защиты общего ресурса
int sharedResource = 0; // Общий ресурс

void increment() {
    mutex.lock(); // Защита доступа к общему ресурсу
    ++sharedResource; // Увеличение общего ресурса
    mutex.unlock(); // Освобождение мьютекса
}

int main() {
    std::thread threads[10]; // Массив потоков

    // Создаем 10 потоков
    for (int i = 0; i < 10; ++i) {
        threads[i] = std::thread(increment); // Инициализация каждого потока
    }

    // Ожидание завершения всех потоков
    for (int i = 0; i < 10; ++i) {
        threads[i].join(); // Присоединение каждого потока
    }

    std::cout << "Общий ресурс: " << sharedResource << std::endl; // Вывод значения общего ресурса
    return 0;
}
```
### 5.1 Зачем нужен мьютекс?

В данной программе мьютекс необходим для предотвращения состояния гонки (race condition). Если бы потоки одновременно пытались изменить значение sharedResource без мьютекса, результат мог бы быть непредсказуемым, и значение могло бы оказаться меньше 10 из-за потерь инкрементов. Использование мьютекса гарантирует, что только один поток в данный момент времени может изменять общий ресурс.

Использование мьютексов при работе с многопоточными программами зависит от того, как потоки взаимодействуют с данными. Если каждый поток работает с отдельной частью вектора (массива) и не изменяет данные в других частях, то вам не нужно использовать мьютексы. Давайте подробнее рассмотрим этот вопрос.

### 5.2 **Ситуация без использования мьютексов**

Если у вас есть вектор, и вы передаете каждому потоку свои границы для работы, например:

```cpp
#include <iostream>
#include <vector>
#include <thread>

void processPart(const std::vector<int>& arr, int start, int end) {
    for (int i = start; i < end; ++i) {
        // Обработка элемента arr[i]
        std::cout << "Processing: " << arr[i] << std::endl;
    }
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    const int numThreads = 2; // Количество потоков
    std::thread threads[numThreads];

    int chunkSize = arr.size() / numThreads;

    // Создание потоков с указанием границ
    for (int i = 0; i < numThreads; ++i) {
        int start = i * chunkSize;
        int end = (i == numThreads - 1) ? arr.size() : (i + 1) * chunkSize; // Обработка последнего сегмента
        threads[i] = std::thread(processPart, std::ref(arr), start, end);
    }

    // Ожидание завершения всех потоков
    for (int i = 0; i < numThreads; ++i) {
        threads[i].join();
    }

    return 0;
}
```

В этом коде:
- Каждый поток обрабатывает свою часть вектора `arr` с заданными границами `start` и `end`.
- Потоки не изменяют одни и те же данные, и каждый поток работает только с частью данных, поэтому **мьютексы не нужны**.

### 5.3 **Ситуация с использованием мьютексов**

Если же потоки могут **изменять общие данные** или если они должны обращаться к одним и тем же элементам массива, тогда вам потребуется мьютекс для синхронизации доступа к этим данным.

Например:

```cpp
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>

std::mutex mutex; // Мьютекс для защиты общего ресурса
std::vector<int> sharedArr(10, 0); // Общий вектор, который потоки будут изменять

void incrementPart(int start, int end) {
    for (int i = start; i < end; ++i) {
        // Блокируем мьютекс для безопасного доступа к sharedArr
        mutex.lock();
        sharedArr[i] += 1; // Увеличиваем элемент
        mutex.unlock();
    }
}

int main() {
    const int numThreads = 2; // Количество потоков
    std::thread threads[numThreads];
    int chunkSize = sharedArr.size() / numThreads;

    // Создание потоков
    for (int i = 0; i < numThreads; ++i) {
        int start = i * chunkSize;
        int end = (i == numThreads - 1) ? sharedArr.size() : (i + 1) * chunkSize;
        threads[i] = std::thread(incrementPart, start, end);
    }

    // Ожидание завершения всех потоков
    for (int i = 0; i < numThreads; ++i) {
        threads[i].join();
    }

    // Вывод значений вектора
    for (const auto& value : sharedArr) {
        std::cout << value << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

В этом коде:
- Мьютекс необходим, поскольку потоки одновременно изменяют один и тот же вектор `sharedArr`. 
- Если мьютекс не будет использоваться, это может привести к состоянию гонки (race condition), и результаты могут быть непредсказуемыми.

- **Если каждый поток работает только с отдельными частями данных** (например, каждый поток обрабатывает разные элементы вектора), **мьютексы не нужны**.
- **Если потоки обращаются к общим данным или изменяют одни и те же элементы**, необходимо использовать **мьютексы** для синхронизации доступа и предотвращения состояния гонки.

### Заключение

Потоки — мощный инструмент в C++, позволяющий создавать многопоточные приложения. Они могут существенно улучшить производительность, но также требуют осторожности, чтобы избежать проблем, таких как состояние гонки и блокировки. Использование мьютексов и других механизмов синхронизации помогает обеспечить корректную работу многопоточных программ.
