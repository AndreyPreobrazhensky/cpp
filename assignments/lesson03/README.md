Урок 3: Современные функции и улучшения в C++17

### Часть 1: `if constexpr` и inline функции

#### 1.1 `if constexpr`

`if constexpr` — это конструкция, добавленная в C++17, которая позволяет компилятору выполнять условие на этапе компиляции. Это улучшение помогает уменьшить количество ошибок в шаблонах и делает код более эффективным, потому что нежелательные ветки не компилируются, если условие известно на этапе компиляции.

##### Основные особенности:
- `if constexpr` используется в шаблонных функциях или коде, который можно выполнить на этапе компиляции.
- В отличие от обычного `if`, ветка кода, не прошедшая условие `if constexpr`, вообще не компилируется, а значит, возможные ошибки в ней не будут мешать компиляции.

##### Пример:

```cpp
template <typename T>
void print(T t) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Целочисленный тип: " << t << std::endl;
    } else {
        std::cout << "Не целочисленный тип: " << t << std::endl;
    }
}
```

Здесь, если `T` — целочисленный тип (например, `int` или `long`), будет скомпилирован первый блок, а если тип — нецелочисленный (например, `double` или `std::string`), будет скомпилирован второй блок.

#### 1.2 Inline-функции

В C++17 концепция inline-функций получила расширение. Теперь можно объявлять **inline переменные**. Ранее переменные, определённые в заголовочных файлах, требовали специальных указаний для корректной работы, чтобы не было множественных определений в разных единицах трансляции.

##### Основные моменты:
- `inline` теперь можно использовать не только с функциями, но и с переменными.
- Inline-функции и переменные полезны, когда требуется, чтобы их можно было определять в нескольких единицах трансляции без дублирования символов.

##### Пример inline переменной:

```cpp
inline int global_value = 10; // Может быть определена в заголовочном файле
```

Теперь эта переменная может быть объявлена в нескольких единицах трансляции без ошибок компоновки.

### Часть 2: Авто-определение типа (`auto`)

#### 2.1 `auto` для упрощения определения типов

`auto` — это механизм автоматического выведения типов, который появился еще в C++11, но в C++17 его применение стало ещё более удобным и распространённым. Он позволяет компилятору автоматически выводить тип переменной на основании выражения, присваиваемого переменной.

##### Преимущества `auto`:
- Упрощает чтение и написание кода, особенно когда типы сложные (например, итераторы или типы шаблонов).
- Снижает риск ошибок, связанных с несоответствием типов.

##### Пример:

```cpp
auto x = 10;       // x имеет тип int
auto y = 3.14;     // y имеет тип double
auto z = "Hello";  // z имеет тип const char*
```

Компилятор автоматически выводит тип переменной на основе инициализатора.

#### 2.2 `auto` и возвращаемый тип функций

Теперь `auto` можно использовать для указания возвращаемого типа функции, который компилятор будет выводить на основании возвращаемого значения.

##### Пример:

```cpp
auto add(int a, int b) {
    return a + b;  // Компилятор выводит, что возвращаемый тип — int
}
```

В случае более сложных функций это делает код более кратким и читабельным.

### Часть 3: Упрощение лямбда-выражений

#### Лямбда-выражения. Напоминание

Лямбда-выражения в C++ — это способ определения анонимных функций прямо в месте их использования. Они были введены в C++11 и позволяют создавать компактные и удобные функции, которые могут захватывать переменные из окружающего контекста. Вот как выглядит синтаксис лямбда-выражения в C++:

```cpp
[capture](parameters) -> return_type {
    // function body
}
```

Вот что означают различные части этого синтаксиса:

- **`[capture]`** — список захвата. Здесь указываются переменные, которые будут захвачены из внешнего контекста. Можно использовать:
  - `[]` — не захватывать ничего,
  - `[&]` — захватить все переменные по ссылке,
  - `[=]` — захватить все переменные по значению,
  - `[var]` — захватить конкретную переменную по значению,
  - `[&var]` — захватить конкретную переменную по ссылке.

- **`(parameters)`** — список параметров лямбда-функции (аналогично обычной функции).

- **`-> return_type`** — (опционально) тип возвращаемого значения. Если он не указан, компилятор сам определит его.

- **`{ ... }`** — тело лямбды, где вы пишете код функции.

Примеры:

1. Простое лямбда-выражение, не захватывающее никакие переменные:

    ```cpp
    auto printHello = []() {
        std::cout << "Hello, World!" << std::endl;
    };
    printHello(); // Вызов лямбда-функции
    ```

2. Лямбда-выражение с захватом переменной по значению:

    ```cpp
    int x = 10;
    auto addX = [x](int y) {
        return x + y;
    };
    std::cout << addX(5); // Вывод: 15
    ```

3. Лямбда-выражение с захватом переменной по ссылке:

    ```cpp
    int x = 10;
    auto incrementX = [&x]() {
        x++;
    };
    incrementX();
    std::cout << x; // Вывод: 11
    ```

Лямбда-выражения полезны в различных ситуациях, например, при работе с алгоритмами из стандартной библиотеки (например, `std::sort`), для реализации обратных вызовов, обработки событий и т.д.

#### 3.1 Лямбда-выражения с автоматическим выводом типов

Лямбда-выражения в C++17 были улучшены для большей гибкости и удобства. Теперь они могут использовать `auto` для параметров, что делает код более универсальным и уменьшает необходимость явного указания типов аргументов.

##### Пример:

```cpp
auto lambda = [](auto a, auto b) {
    return a + b;
};

std::cout << lambda(1, 2) << std::endl;        // Вывод: 3
std::cout << lambda(1.5, 2.5) << std::endl;    // Вывод: 4.0
```

Теперь лямбда может принимать любые типы данных (например, целые числа, числа с плавающей запятой) без явного указания типа в определении.

#### 3.2 Захват по значению и по ссылке

Лямбда-выражения по-прежнему поддерживают захват переменных из внешнего контекста. Это может быть сделано как по значению, так и по ссылке.

##### Пример захвата переменных:

```cpp
int x = 10;
auto lambda = [x]() mutable {
    return ++x; // x захвачен по значению, но лямбда изменяет локальную копию
};

std::cout << lambda() << std::endl;  // Вывод: 11
std::cout << x << std::endl;         // Вывод: 10
```

Использование `mutable` позволяет изменять копии захваченных переменных.

#### 3.3 Захват всего контекста

В C++17 появилась возможность захватывать все переменные из внешнего контекста сразу, используя символ `*`.

##### Пример:

```cpp
int a = 5, b = 10;
auto lambda = [=, &b]() {
    return a + b++;  // a захвачен по значению, b — по ссылке
};

lambda();
std::cout << b << std::endl;  // b был изменён
```

### Заключение

C++17 привносит множество улучшений, которые упрощают написание и поддержку кода, делая его более читаемым, компактным и эффективным. `if constexpr` позволяет писать более оптимизированный код на этапе компиляции, inline-функции и переменные упрощают работу с заголовочными файлами, `auto` автоматизирует вывод типов, а улучшенные лямбда-выражения делают функциональный стиль программирования проще и удобнее.

# Практические задания

Задачи L03-*
