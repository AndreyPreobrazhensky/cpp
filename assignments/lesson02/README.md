# Основы объектно-ориентированного программирования в C++

## Основные концепции ООП:
- Классы
- Объекты
- Наследование
- Инкапсуляция
- Полиморфизм

## 1. Классы и объекты в C++

**Класс** — это пользовательский тип данных, который объединяет данные (переменные) и функции (методы) для работы с этими данными. Он служит шаблоном для создания объектов.

**Объект** — это экземпляр класса, конкретная реализация, которая хранит свои уникальные значения полей.

### Пример:
```cpp
#include <iostream>

class Car {
public:
    std::string brand;
    int speed;

    void drive() {
        std::cout << brand << " is driving at " << speed << " km/h\n";
    }
};

int main() {
    Car car1;  // Создание объекта класса Car
    car1.brand = "Toyota";
    car1.speed = 120;
    car1.drive();  // Вызов метода объекта

    return 0;
}
```

## 2. Конструкторы и деструкторы

Конструктор — это специальный метод класса, который вызывается автоматически при создании объекта и инициализирует его поля. Конструкторы могут быть с параметрами и без них (конструктор по умолчанию).

Деструктор — это метод, который автоматически вызывается при уничтожении объекта и освобождает ресурсы.

### Пример
```cpp
#include <iostream>

class Car {
public:
    std::string brand;
    int speed;

    // Конструктор
    Car(std::string b, int s) : brand(b), speed(s) {
        std::cout << "Car " << brand << " created\n";
    }

    // Деструктор
    ~Car() {
        std::cout << "Car " << brand << " destroyed\n";
    }

    void drive() {
        std::cout << brand << " is driving at " << speed << " km/h\n";
    }
};

int main() {
    Car car1("Toyota", 120);  // Вызов конструктора
    car1.drive();

    return 0;  // В конце программы вызовется деструктор
}
```
В этом примере конструктор Car инициализирует поля объекта brand и speed. Деструктор вызывается автоматически при завершении работы программы.

## 3. Наследование и работа с иерархиями классов

Наследование позволяет создавать новые классы на основе уже существующих. Производный класс наследует все поля и методы базового класса, но может добавлять новые поля, методы или переопределять (override) существующие.

```cpp
#include <iostream>

class Vehicle {
public:
    int speed;
    
    void drive() {
        std::cout << "Vehicle is driving at " << speed << " km/h\n";
    }
};

class Car : public Vehicle {
public:
    std::string brand;

    void drive() {  // Переопределение метода
        std::cout << brand << " is driving at " << speed << " km/h\n";
    }
};

class Bike : public Vehicle {
public:
    bool hasPedals;

    void ringBell() {
        std::cout << "Bike is ringing the bell!\n";
    }
};

int main() {
    Car car;
    car.brand = "Toyota";
    car.speed = 120;
    car.drive();  // Вызов метода Car

    Bike bike;
    bike.speed = 30;
    bike.hasPedals = true;
    bike.drive();  // Вызов метода Vehicle
    bike.ringBell();  // Вызов метода Bike

    return 0;
}
```
Здесь Car и Bike наследуют от базового класса Vehicle. Класс Car переопределяет метод drive(), а класс Bike добавляет новый метод ringBell().

## 4. Виртуальные функции и полиморфизм

Виртуальные функции и полиморфизм — это ключевые концепции объектно-ориентированного программирования (ООП) в C++. Они позволяют реализовать динамическое поведение объектов, которое зависит от их типа во время выполнения программы.

### Виртуальная функция

Виртуальная функция — это функция-член класса, объявленная с ключевым словом *virtual* в базовом классе, что позволяет производным классам переопределять эту функцию для предоставления специфической реализации.

### Пример

```cpp
#include <iostream>

class Animal {
public:
    virtual void speak() {  // Виртуальная функция
        std::cout << "Animal speaks\n";
    }
};

class Dog : public Animal {
public:
    void speak() override {  // Переопределение виртуальной функции
        std::cout << "Dog barks\n";
    }
};

class Cat : public Animal {
public:
    void speak() override {  // Переопределение виртуальной функции
        std::cout << "Cat meows\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->speak();  // Вызывает Dog::speak
    a2->speak();  // Вызывает Cat::speak

    delete a1;
    delete a2;

    return 0;
}
```

В этом примере класс Animal имеет виртуальную функцию speak(). Производные классы Dog и Cat переопределяют эту функцию, предоставляя свою реализацию. Когда функция speak() вызывается через указатель типа Animal*, C++ определяет, какую версию функции вызывать (из Dog или Cat) на основе фактического типа объекта, на который указывает указатель. Это поведение называется динамическим связыванием.

### Чисто виртуальная функция

Чисто виртуальная функция (или абстрактная функция) — это функция, которая не имеет реализации в базовом классе и должна быть переопределена в производных классах. Объявляется с помощью = 0 в базовом классе. Классы, содержащие чисто виртуальные функции, называются абстрактными и не могут быть инстанцированы напрямую.

### Пример с чисто виртуальной функцией и виртуальными деструкторами:
```cpp
#include <iostream>

class Animal {
public:
    virtual ~Animal() {  // Виртуальный деструктор
        std::cout << "Animal destructor called\n";
    }
    virtual void speak() const = 0;  // Чисто виртуальная функция
};

class Dog : public Animal {
public:
    void speak() const override {  // Переопределение чисто виртуальной функции
        std::cout << "Dog barks\n";
    }

    ~Dog() {  // Деструктор класса Dog
        std::cout << "Dog destructor called\n";
    }
};

class Cat : public Animal {
public:
    void speak() const override {  // Переопределение чисто виртуальной функции
        std::cout << "Cat meows\n";
    }

    ~Cat() {  // Деструктор класса Cat
        std::cout << "Cat destructor called\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->speak();  // Вызывает Dog::speak
    a2->speak();  // Вызывает Cat::speak

    delete a1;  // Правильно вызывает деструктор Dog, затем деструктор Animal
    delete a2;  // Правильно вызывает деструктор Cat, затем деструктор Animal

    return 0;
}
```
В этом примере класс Animal содержит чисто виртуальную функцию speak() и виртуальный деструктор. Классы Dog и Cat переопределяют чисто виртуальную функцию speak(). При удалении объектов через указатели типа Animal*, корректно вызываются деструкторы производных классов Dog и Cat, а затем деструктор базового класса Animal.

### Полиморфизм

Полиморфизм (от греч. "много форм") — это возможность функции обрабатывать объекты разных типов через единый интерфейс. В контексте виртуальных функций полиморфизм позволяет писать более гибкий и расширяемый код, в котором один и тот же код может работать с объектами разных классов.

### Полиморфизм бывает двух видов:

1 Компиляторный (статический) полиморфизм: реализуется с помощью перегрузки функций и шаблонов. Выбор нужной функции происходит во время компиляции.

2 Исполняемый (динамический) полиморфизм: реализуется через виртуальные функции. Выбор нужной функции происходит во время выполнения программы, в зависимости от типа объекта, на который указывает указатель или ссылка.

Пример выше демонстрирует динамический полиморфизм. Объекты типа Dog и Cat ведут себя по-разному при вызове функции speak(), несмотря на то, что они рассматриваются как объекты типа Animal. Это возможно благодаря тому, что speak() объявлена как виртуальная функция в базовом классе.

## Заключение

Виртуальные функции используются для создания функций, которые могут быть переопределены в производных классах.

Полиморфизм позволяет использовать указатели или ссылки на базовый класс для работы с объектами производных классов, обеспечивая гибкость и расширяемость кода.

Классы и объекты, конструкторы и деструкторы, наследование и полиморфизм — это фундаментальные концепции, на которых строятся гибкие системы на языке C++.

