# Урок 7: **Стандартные алгоритмы и контейнеры**

### Цели урока:
- Познакомиться с основными контейнерами в языке C++: `std::vector`, `std::list`, `std::map`, `std::set`
- Изучить базовые стандартные алгоритмы: `std::sort`, `std::find`, `std::accumulate`
- Рассмотреть примеры практического применения этих контейнеров и алгоритмов для решения задач программирования

---

### **1. Введение в стандартные контейнеры STL (Standard Template Library)**

STL предоставляет разработчику набор контейнеров (структур данных) и алгоритмов для удобного и эффективного хранения и обработки данных. В STL есть различные типы контейнеров, которые отличаются своими свойствами и характеристиками.

#### 1.1. `std::vector`
- Представляет собой динамический массив.
- Элементы размещаются последовательно в памяти.
- Поддерживает прямой доступ по индексу (быстрый доступ по индексу).
- При добавлении элементов в конец контейнера автоматически увеличивает свою емкость.

Пример:
```cpp
std::vector<int> numbers = {1, 2, 3, 4};
numbers.push_back(5); // Добавляем элемент в конец
```

#### 1.2. `std::list`
- Представляет двусвязный список.
- Поддерживает быструю вставку и удаление элементов в любом месте списка.
- Нет прямого доступа к элементам по индексу (по сравнению с `vector` это медленнее).

Пример:
```cpp
std::list<int> numbers = {1, 2, 3, 4};
numbers.push_back(5); // Добавляем элемент в конец
numbers.push_front(0); // Добавляем элемент в начало
```

#### 1.3. `std::map`
- Отображение ключ-значение (ассоциативный массив).
- Ключи уникальны и сортируются по возрастанию (по умолчанию).
- Обеспечивает быстрый поиск по ключу.

Пример:
```cpp
std::map<std::string, int> students;
students["Alice"] = 10;
students["Bob"] = 12;
```

#### 1.4. `std::set`
- Множество уникальных элементов.
- Элементы сортируются автоматически.
- Быстрая вставка, удаление и поиск.

Пример:
```cpp
std::set<int> uniqueNumbers = {1, 2, 3, 4};
uniqueNumbers.insert(5); // Добавляем элемент
```

### **2. Стандартные алгоритмы**

STL также предлагает множество алгоритмов для обработки данных в контейнерах. Эти алгоритмы универсальны и не зависят от типа контейнера.

#### 2.1. `std::sort`
- Используется для сортировки диапазона элементов.
- Работает с любыми контейнерами, поддерживающими итераторы.

Пример:
```cpp
std::vector<int> numbers = {4, 2, 3, 1};
std::sort(numbers.begin(), numbers.end()); // Сортировка в порядке возрастания
```

#### 2.2. `std::find`
- Используется для поиска элемента в диапазоне.
- Возвращает итератор на найденный элемент или конец контейнера, если элемент не найден.

Пример:
```cpp
std::vector<int> numbers = {1, 2, 3, 4};
auto it = std::find(numbers.begin(), numbers.end(), 3);
if (it != numbers.end()) {
    std::cout << "Элемент найден!" << std::endl;
}
```

#### 2.3. `std::accumulate`
- Используется для вычисления суммы (или другой операции) всех элементов в диапазоне.
- Может применяться для более сложных вычислений, передавая функцию как аргумент.

Пример:
```cpp
std::vector<int> numbers = {1, 2, 3, 4};
int sum = std::accumulate(numbers.begin(), numbers.end(), 0); // Суммируем все элементы
```

### **3. Практические примеры использования контейнеров и алгоритмов**

#### Пример 1: Сортировка списка студентов по баллам
```cpp
std::map<std::string, int> students = {{"Alice", 85}, {"Bob", 92}, {"Charlie", 78}};
std::vector<std::pair<std::string, int>> sortedStudents(students.begin(), students.end());
std::sort(sortedStudents.begin(), sortedStudents.end(),
          [](const auto& a, const auto& b) { return a.second > b.second; });

for (const auto& student : sortedStudents) {
    std::cout << student.first << ": " << student.second << std::endl;
}
```

#### Пример 2: Поиск элемента в множестве
```cpp
std::set<int> numbers = {1, 2, 3, 4, 5};
if (numbers.find(3) != numbers.end()) {
    std::cout << "Элемент 3 найден!" << std::endl;
}
```

#### Пример 3: Накопление суммы элементов в векторе
```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
int total = std::accumulate(numbers.begin(), numbers.end(), 0);
std::cout << "Сумма элементов: " << total << std::endl;
```

---

# **Домашнее задание**

Выполняем финальное домашнее задание по рефакторингу игры "[Snake](https://github.com/msu-cmc-sqi/cpp/tree/main/assignments/snake)" (assignments/snake). Все задачи накладываются друг на друга, а проект должен представлять собой единую программу, состоящую из нескольких файлов. Отдельные решения предыдущих задач должны быть интегрированы в основной проект. 

**Требования к сдаче:**
- Все изменения вносятся в один проект, который развивается с каждым новым заданием. Для этого используются Pull Requests.
- Необходимо настроить сборку проекта через `Makefile` или `CMake`, чтобы программа могла корректно собираться и запускаться.

Сейчас вам нужно реализовать **первый пункт** из задания: **Рефакторинг кода**.

#### Первый Pull Request:
1. **Рефакторинг кода**:
    - Разделите код на функции и классы в соответствии с принципами чистого кода.
    - Избегайте дублирования кода.
    - Переменные и методы должны иметь осмысленные и понятные имена.
    - Минимизируйте использование глобальных переменных и перенесите логику в классы и методы.
    - Добавьте комментарии для улучшения понимания структуры программы.

2. **Важно**:
    - В этом этапе **не требуется** добавлять новую функциональность (например, вторую змейку или многопоточность). Это будет реализовано в следующих Pull Requests.
    - Обратите внимание на то, чтобы код был структурирован и легко читаем.

3. **Deadline**
    - 29 октября

#### Дополнительно:
- Убедитесь, что в репозитории настроена правильная структура, позволяющая легко работать с проектом и его сборкой.
- Подготовьте проект к тому, чтобы его можно было собрать с помощью `Makefile` или `CMake`.
