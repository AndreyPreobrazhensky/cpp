# Урок 8: Современные возможности языка C++

#### Тема: `constexpr` функции, раннее вычисление выражений и расширенные возможности работы с типами

---

### План урока

1. **Введение**
2. **`constexpr` функции и их использование**
3. **Раннее вычисление выражений (compile-time evaluation)**
4. **Расширенные возможности работы с типами**
    - `Structured Bindings`
    - `Fold Expressions`
5. **Закрепление материала: упражнения и задачи**

---

### 1. Введение

С++11 и более поздние стандарты (С++14, С++17, С++20) привнесли в язык несколько возможностей для оптимизации кода. Сегодня мы рассмотрим три ключевые темы:
   - `constexpr` функции и их роль в оптимизации времени компиляции.
   - Механизм compile-time evaluation, позволяющий вычислять выражения на этапе компиляции.
   - Современные способы работы с типами, такие как `structured bindings` для упрощённого доступа к элементам кортежей, пар и массивов, а также `fold expressions` для работы с вариативными шаблонами.

### 2. `constexpr` функции и их использование

**Что такое `constexpr`?**
- `constexpr` — это спецификатор, позволяющий пометить функции и переменные для вычисления на этапе компиляции, если переданные в них аргументы также являются константами времени компиляции.
- Основное преимущество `constexpr` функций — возможность выполнять вычисления до запуска программы, что значительно повышает её производительность.

**Пример использования:**
```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : (n * factorial(n - 1));
}

int main() {
    constexpr int result = factorial(5); // Вычисление произойдёт на этапе компиляции
    std::cout << result << std::endl;     // Выведет 120
    return 0;
}
```

**Особенности:**
- В С++11 `constexpr` функции должны быть очень простыми (состоящими из одного оператора `return`).
- В С++14 и более поздних версиях ограничения были смягчены, и `constexpr` функции теперь могут содержать переменные и более сложные конструкции (например, циклы и ветвления).

### 3. Раннее вычисление выражений (compile-time evaluation)

**Compile-time evaluation** позволяет вычислять выражения на этапе компиляции, что особенно полезно для создания оптимизированного кода.
- С++ позволяет некоторым выражениям, включая вызовы `constexpr` функций, вычисляться до запуска программы, если все их операнды известны на этапе компиляции.
- Это помогает избегать затрат на вычисления во время выполнения программы.

**Пример:**
```cpp
#include <array>

constexpr int square(int x) { return x * x; }

int main() {
    constexpr int N = 10;
    std::array<int, square(N)> arr; // Размер массива вычислен на этапе компиляции
    return 0;
}
```

### 4. Расширенные возможности работы с типами

#### 4.1. Structured Bindings

**Structured bindings** были добавлены в C++17 и позволяют проще работать с составными типами, такими как кортежи (`std::tuple`), пары (`std::pair`) и массивы.

**Пример использования:**
```cpp
#include <tuple>
#include <iostream>

std::tuple<int, double, std::string> getValues() {
    return {42, 3.14, "Hello"};
}

int main() {
    auto [intValue, doubleValue, stringValue] = getValues();
    std::cout << intValue << ", " << doubleValue << ", " << stringValue << std::endl;
    return 0;
}
```

**Преимущества:**
- Улучшение читаемости кода за счёт прямого доступа к элементам кортежей и пар.
- Меньше кода для манипуляции составными типами.

#### 4.2. Fold Expressions

**Fold expressions** появились в C++17 и предназначены для работы с вариативными шаблонами, позволяя легко выполнять операции над набором аргументов.
- Это особенно полезно, когда нужно применить одно и то же выражение ко всем параметрам шаблона, например, для суммирования или логического объединения.

**Пример использования:**
```cpp
#include <iostream>

template<typename... Args>
auto sum(Args... args) {
    return (args + ...); // Унарное fold expression (отправляет результат влево)
}

int main() {
    std::cout << sum(1, 2, 3, 4, 5) << std::endl; // Выведет 15
    return 0;
}
```

**Типы fold expressions:**
- **Унарные** (Left Fold): `(args + ...)`, результат сворачивается слева направо.
- **Бинарные** (Right Fold): `(... + args)`, результат сворачивается справа налево.

# Домашнее задание: Добавление второй змейки в игру Snake

#### Задача 2: Добавление второй змейки с использованием многопоточности

В этом задании вам предстоит расширить функционал игры Snake, добавив в неё **вторую змейку**, которая может управляться либо вторым игроком, либо двигаться автоматически. Для этого потребуется задействовать многопоточность с помощью `std::thread` и настроить синхронизацию потоков, чтобы обе змейки корректно обновляли игровое поле.

**Требования к сдаче:**
- Все изменения вносятся в один проект, который развивается с каждым новым заданием. Для этого используются Pull Requests.

### Шаги выполнения

#### 1. **Создание второй змейки**

   - В уже существующем коде создайте ещё один объект класса `Snake`, который будет представлять вторую змейку.
   - Убедитесь, что вторая змейка имеет свою собственную логику движения и независимый от первой цвет или стиль отображения на игровом поле.

#### 2. **Определение логики управления второй змейкой**

   Вам предлагается на выбор два варианта:
   
   - **Управление вторым игроком**:
     - Добавьте отдельные клавиши для управления второй змейкой (например, клавиши `W`, `A`, `S`, `D` для направления вверх, влево, вниз и вправо соответственно).
     - Следите за тем, чтобы управление обеими змейками не конфликтовало и обрабатывалось одновременно.

   - **Автоматическое движение**:
     - Реализуйте логику автоматического движения второй змейки. Например, вторая змейка может следовать за первой с некоторым отставанием, избегать препятствий, двигаться в случайном направлении или следовать заранее запрограммированному пути.
     - Вы можете создать простой алгоритм для автоматического передвижения (например, случайное направление движения или движение к случайным точкам на игровом поле).

#### 3. **Многопоточность с использованием `std::thread`**

   - Создайте отдельный поток для второй змейки с использованием `std::thread`.
   - Поток второй змейки должен постоянно работать, пока идет игра, и обновлять положение змейки на игровом поле.

#### 4. **Синхронизация потоков**

   - Для корректного обновления игрового поля вам потребуется синхронизировать работу потоков.
   - Используйте средства синхронизации, такие как `std::mutex` и `std::lock_guard`, чтобы исключить одновременное изменение игрового поля обоими потоками.
   - Убедитесь, что доступ к общим ресурсам (например, игровому полю) выполняется безопасно.

#### 5. **Обработка столкновений**

   - Реализуйте логику для определения столкновений второй змейки как с первой змейкой, так и с собственным телом.
   - При обнаружении столкновения с другой змейкой или препятствием игра должна завершаться, и на экран должно выводиться соответствующее сообщение.

### Критерии выполнения

1. **Корректность многопоточности**:
   - Потоки обеих змей должны работать независимо и не блокировать друг друга.
   - Игровое поле должно обновляться корректно и без артефактов, вызванных одновременным доступом.

2. **Управление**:
   - Управление для второй змейки должно работать корректно.
   - Если вторая змейка управляется автоматически, движение должно выглядеть логично и не конфликтовать с первой змейкой.

3. **Обработка коллизий**:
   - Столкновения между змейками и с препятствиями должны корректно обрабатываться, вызывая завершение игры, если это необходимо.

4. **Читаемость и стиль кода**:
   - Комментарии, объясняющие логику многопоточности и синхронизации.
   - Хорошо структурированный код, который легко понять и поддерживать.

5. **Deadline**
    - 12 ноября - необходимо сделать Pull Request

### Рекомендации

- Регулярно проверяйте код на корректность работы и отсутствие артефактов или ошибок в синхронизации.
- Используйте дебаггинг для отслеживания возможных конфликтов между потоками.
- Делайте коммиты по каждому важному шагу и используйте Pull Requests для удобства проверки и обсуждения изменений.



